{"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;AEOO,SAAS,0CAAS,MAAM;IAC7B,OAAO,CAAA,GAAA,eAAO,EAAE,IAAM,OAAO,KAAK;AACpC;;;;ACFO,SAAS,0CAAI,YAAY;IAC9B,MAAM,YAAY,CAAA,GAAA,aAAK,EAAE;IAEzB;;;GAGC,GACD,MAAM,QAAQ,CAAC;QACb,UAAU,KAAK,GAAG;IACpB;IAEA,OAAO,cAAc,CAAC,OAAO,WAAW;QACtC;YACE,OAAO,UAAU,KAAK;QACxB;QACA,YAAY;QACZ,cAAc;IAChB;IAEA,OAAO;AACT;AAMO,SAAS,0CAAa,IAAI;IAC/B,2CAA2C,GAC3C,MAAM,SAAS;IAEf,CAAA,GAAA,aAAK,EAAE;QACL,KAAK,OAAO,CAAC,CAAC,MAAQ,IAAI,OAAO,OAAO;IAC1C;IAEA,OAAO;AACT;;;;;;;;;;;;;;;;AEhCO,SAAS,0CAAc,SAAS,EAAE,QAAQ;IAC/C,iDAAiD,GACjD,MAAM,YAAY,CAAA,GAAA,yCAAE;IACpB,0FAA0F,GAC1F,MAAM,cAAc,CAAA,GAAA,aAAK,EAAE;IAE3B,MAAM,MAAM,CAAA,GAAA,aAAK,EAAE;QACjB,MAAM,aAAa,IAAI;QACvB,UAAU,OAAO,EAAE,iBACjB,WACA,yDAAyD,GACzD,aAAa;QACb,CAAC;YACC,YAAY,KAAK,GAAG;YACpB,WAAW;QACb,GACA;YAAE,QAAQ,WAAW,MAAM;QAAC;QAG9B,OAAO,IAAM,WAAW,KAAK;IAC/B;IAEA,OAAO;mBAAE;QAAW,KAAK;QAAW,OAAO,CAAA,GAAA,yCAAO,EAAE;aAAc;IAAI;AACxE;;;;;;;;;;AC5BO,SAAS;IACd,MAAM,OAAO,CAAA,GAAA,aAAK,EAAE;IAEpB,MAAM,EAAE,KAAK,YAAY,EAAE,KAAK,YAAY,EAAE,GAAG,CAAA,GAAA,yCAAY,EAC3D,aACA,IAAO,KAAK,KAAK,GAAG;IAGtB,MAAM,EAAE,KAAK,UAAU,EAAE,KAAK,UAAU,EAAE,GAAG,CAAA,GAAA,yCAAY,EACvD,WACA,IAAO,KAAK,KAAK,GAAG;IAGtB,MAAM,MAAM;QACV;QACA;IACF;IAEA,OAAO;QACL,kDAAkD,GAClD,aAAa;QACb,KAAK,CAAA,GAAA,yCAAW,EAAE;YAAC;YAAc;SAAW;QAC5C,MAAM,CAAA,GAAA,yCAAO,EAAE;aACf;QACA,SAAS;IACX;AACF;;;AFrBO,SAAS,0CAAU,WAAE,OAAO,EAAE,GAAG,CAAC,CAAC;IACxC,MAAM,WAAW,CAAA,GAAA,aAAK,EAAE;IAExB,uEAAuE,GACvE,MAAM,EAAE,KAAK,YAAY,EAAE,KAAK,YAAY,EAAE,GAAG,CAAA,GAAA,yCAAY,EAC3D,aACA,CAAC;QACC,SAAS,KAAK,GAAG;QAEjB,IAAI,SACF,MAAM,YAAY,EAAE,WAAW,QAAQ;IAE3C;IAGF,qEAAqE,GACrE,MAAM,EAAE,KAAK,UAAU,EAAE,KAAK,UAAU,EAAE,GAAG,CAAA,GAAA,yCAAY,EAAE,WAAW;QACpE,SAAS,KAAK,GAAG;IACnB;IAEA,MAAM,EACJ,KAAK,SAAS,EACd,MAAM,mBAAmB,EACzB,KAAK,YAAY,EAClB,GAAG,CAAA,GAAA,yCAAQ;IAEZ,MAAM,YAAY,CAAA,GAAA,yCAAW,EAAE;QAAC;QAAc;KAAW;IACzD,MAAM,cAAc,CAAA,GAAA,eAAO,EACzB,IAAM,CAAC,UAAU,OAAO,IAAI,oBAAoB,KAAK;IAGvD,MAAM,MAAM,CAAA,GAAA,aAAK,EAAE;QACjB,MAAM,SAAS,UAAU,OAAO;QAEhC,IAAI,QACF,OAAO,SAAS,GAAG,YAAY,KAAK;IAExC;IAEA,OAAO;QACL,KAAK;mBACL;QACA,UAAU,CAAA,GAAA,yCAAO,EAAE;QACnB,KAAK;YACH;YACA;YACA;YACA;QACF;IACF;AACF;AAMO,SAAS,0CAAU,UAAE,MAAM,EAAE,GAAG,CAAC,CAAC;IACvC,MAAM,WAAW,CAAA,GAAA,aAAK,EAAE;IAExB,uEAAuE,GACvE,MAAM,EAAE,KAAK,YAAY,EAAE,KAAK,YAAY,EAAE,GAAG,CAAA,GAAA,yCAAY,EAC3D,aACA,CAAC;QACC,MAAM,cAAc;QACpB,SAAS,KAAK,GAAG;IACnB;IAGF,sEAAsE,GACtE,MAAM,EAAE,KAAK,WAAW,EAAE,KAAK,WAAW,EAAE,GAAG,CAAA,GAAA,yCAAY,EACzD,YACA,CAAC,QAAU,MAAM,cAAc;IAGjC,uEAAuE,GACvE,MAAM,EAAE,KAAK,YAAY,EAAE,KAAK,YAAY,EAAE,GAAG,CAAA,GAAA,yCAAY,EAC3D,aACA,CAAC;QACC,MAAM,cAAc;QACpB,MAAM,WAAE,OAAO,WAAE,OAAO,EAAE,GAAG;QAC7B,MAAM,OAAO,aAAa,OAAO,EAAE;QAEnC,IACE,QACC,CAAA,WAAW,KAAK,GAAG,IAClB,WAAW,KAAK,MAAM,IACtB,WAAW,KAAK,IAAI,IACpB,WAAW,KAAK,KAAK,AAAD,GAEtB,SAAS,KAAK,GAAG;IAErB;IAGF,kEAAkE,GAClE,MAAM,EAAE,KAAK,OAAO,EAAE,KAAK,OAAO,EAAE,GAAG,CAAA,GAAA,yCAAY,EAAE,QAAQ,CAAC;QAC5D,SAAS,KAAK,GAAG;QACjB,SAAS;IACX;IAEA,MAAM,YAAY,CAAA,GAAA,yCAAW,EAAE;QAC7B;QACA;QACA;QACA;KACD;IAED,OAAO;QACL,KAAK;QACL,UAAU,CAAA,GAAA,yCAAO,EAAE;QACnB,KAAK;YACH;YACA;YACA;YACA;QACF;IACF;AACF;;;AHtHO,SAAS,0CAAgB,QAAQ,EAAE;IACxC,MAAM,cAAc,CAAA,GAAA,aAAK,EAAE;IAC3B;;;;;;;;;;;;;GAaC,GACD,MAAM,qBAAqB,CAAA,GAAA,aAAK,EAAE,EAAE;IAEpC;;;GAGC,GACD,SAAS,YAAY,IAAI,EAAE,EAAE;QAC3B,MAAM,MAAM;eAAI,YAAY,KAAK;SAAC;QAElC,IAAI,KAAK,KAAK,KAAK,IAAI,MAAM,GAAG,GAC9B;QAGF,MAAM,UAAU,IAAI,MAAM,CAAC,MAAM,EAAE,CAAC,EAAE;QACtC,IAAI,MAAM,CAAC,IAAI,GAAG;QAClB,YAAY,KAAK,GAAG;IACtB;IAEA,MAAM,MAAM,CAAA,GAAA,aAAK,EAAE;QACjB,MAAM,eAAe,YAAY,KAAK,CAAC,GAAG,CAAC,CAAC,MAAM;YAChD,MAAM,EACJ,KAAK,YAAY,aACjB,SAAS,YACT,QAAQ,EACR,KAAK,YAAY,EAClB,GAAG,CAAA,GAAA,yCAAQ,EAAE;gBAAE,SAAS,IAAM;wBAAC;wBAAQ,MAAM,QAAQ;qBAAG;YAAC;YAE1D,MAAM,EACJ,KAAK,YAAY,YACjB,QAAQ,EACR,KAAK,YAAY,EAClB,GAAG,CAAA,GAAA,yCAAQ,EAAE;gBACZ,QAAQ,CAAC;oBACP,MAAM,OAAO,MAAM,YAAY,EAAE,QAAQ;oBAEzC,IAAI,MACF,YAAY,SAAS,MAAM,KAAK;gBAEpC;YACF;YAEA,OAAO;sBACL;0BACA;0BACA;gBACA,KAAK,CAAA,GAAA,yCAAW,EAAE;oBAAC;oBAAc;iBAAa;2BAC9C;8BACA;8BACA;gBACA,QAAQ,IAAM,YAAY,OAAO,QAAQ;gBACzC,UAAU,IAAM,YAAY,OAAO,QAAQ;gBAC3C,WAAW,IAAM,YAAY,OAAO;gBACpC,KAAK;oBACH;oBACA;gBACF;YACF;QACF,GAAG,IAAI;QAEP,mBAAmB,KAAK,GAAG,aAAa,GAAG,CAAC,CAAC,OAAE,GAAG,EAAE,GAAG,MAAM,GAAK;QAElE,OAAO,IAAM,aAAa,OAAO,CAAC,CAAC,OAAE,GAAG,EAAE,GAAK;IACjD;IAEA,OAAO;QACL,OAAO,CAAA,GAAA,yCAAO,EAAE;aAChB;IACF;AACF;;;;;;;;;;;;;AO1FO,SAAS,0CAAY,YAAY,KAAK;IAC3C,MAAM,KAAK,CAAA,GAAA,aAAK,EAAE;IAElB,OAAO;QACL,IAAI,CAAA,GAAA,yCAAO,EAAE;QACb;YACE,GAAG,KAAK,GAAG,CAAC,GAAG,KAAK;QACtB;IACF;AACF;;;ADRO,SAAS,0CAAa,OAAO,KAAK;IACvC,MAAM,EAAE,IAAI,OAAO,UAAE,MAAM,EAAE,GAAG,CAAA,GAAA,yCAAU,EAAE;IAE5C,OAAO;QACL,SAAS,CAAA,GAAA,yCAAO,EAAE;QAClB,WAAW,CAAA,GAAA,eAAO,EAAE,IAAO,QAAQ,KAAK,GAAG,SAAS;gBACpD;IACF;AACF;;;;;;;;;AELO,SAAS,0CAAa,mBAAmB,KAAK;IACnD,MAAM,EAAE,KAAK,SAAS,EAAE,GAAG,CAAA,GAAA,yCAAY,EACrC,SACA,IAAO,UAAU,KAAK,GAAG,CAAC,UAAU,KAAK;IAE3C,MAAM,YAAY,CAAA,GAAA,aAAK,EAAE;IACzB,MAAM,cAAc,CAAA,GAAA,eAAO,EAAE,IAAO,UAAU,KAAK,GAAG,SAAS;IAC/D,MAAM,KAAK,CAAA,GAAA,eAAO,EAAE,IAClB,UAAU,OAAO,YAAY,oBAAoB,UAAU,OAAO,GAAG;IAEvE,MAAM,UAAU,CAAA,GAAA,aAAK,EAAE,IACrB,GAAG,KAAK,EAAE,aAAa,gBAAgB,YAAY,KAAK;IAG1D,OAAO;QACL,4DAA4D,GAC5D,aAAa;QACb,KAAK;QACL,WAAW,CAAA,GAAA,yCAAO,EAAE;iBACpB;IACF;AACF;","sources":["src/components.js","src/components/reorderableList.js","src/readonly.js","src/ref.js","src/tools/dragAndDrop.js","src/tools/eventListener.js","src/tools/mousedown.js","src/components/showPassword.js","src/tools/toggleValue.js","src/components/toggleButton.js"],"sourcesContent":["export * from './components/reorderableList.js';\nexport * from './components/showPassword.js';\nexport * from './components/toggleButton.js';\n","import { effect, signal } from '@preact/signals-core';\nimport { readonly } from '../readonly.js';\nimport { forwardedRef } from '../ref.js';\nimport { draggable, droppable } from '../tools/dragAndDrop.js';\n\n/**\n * @template T\n * @param {T[]} items\n */\nexport function reorderableList(items = []) {\n  const itemsSignal = signal(items);\n  /**\n   * @type {import('../global.d.ts').Signal<{\n   *   item: T;\n   *   dragging: import('../global.d.ts').ReadonlySignal<boolean>;\n   *   dropping: import('../global.d.ts').ReadonlySignal<boolean>;\n   *   ref: import('../global.d.ts').Ref<HTMLElement>;\n   *   handleRef: import('../global.d.ts').Ref<Element>;\n   *   draggableRef: import('../global.d.ts').Ref<HTMLElement>;\n   *   droppableRef: import('../global.d.ts').Ref<HTMLElement>;\n   *   moveUp: () => void;\n   *   moveDown: () => void;\n   *   moveToTop: () => void;\n   * }[]>}\n   */\n  const wrappedItemsSignal = signal([]);\n\n  /**\n   * @param {number} from \n   * @param {number} to \n   */\n  function moveToIndex(from, to) {\n    const arr = [...itemsSignal.value];\n\n    if (to < 0 || to > arr.length - 1) {\n      return;\n    }\n\n    const element = arr.splice(from, 1)[0];\n    arr.splice(to, 0, element);\n    itemsSignal.value = arr;\n  }\n\n  const end = effect(() => {\n    const wrappedItems = itemsSignal.value.map((item, index) => {\n      const {\n        ref: draggableRef,\n        handleRef,\n        dragging,\n        end: endDraggable,\n      } = draggable({ getData: () => ['text', index.toString()] });\n\n      const {\n        ref: droppableRef,\n        dropping,\n        end: endDroppable,\n      } = droppable({\n        onDrop: (event) => {\n          const data = event.dataTransfer?.getData('text');\n\n          if (data) {\n            moveToIndex(parseInt(data, 10), index);\n          }\n        },\n      });\n\n      return {\n        item,\n        dragging,\n        dropping,\n        ref: forwardedRef([draggableRef, droppableRef]),\n        handleRef,\n        draggableRef,\n        droppableRef,\n        moveUp: () => moveToIndex(index, index - 1),\n        moveDown: () => moveToIndex(index, index + 1),\n        moveToTop: () => moveToIndex(index, 0),\n        end: () => {\n          endDraggable();\n          endDroppable();\n        },\n      };\n    }).flat();\n\n    wrappedItemsSignal.value = wrappedItems.map(({ end, ...item }) => item);\n\n    return () => wrappedItems.forEach(({ end }) => end());\n  });\n\n  return {\n    items: readonly(wrappedItemsSignal),\n    end,\n  }\n}\n","import { computed } from \"@preact/signals-core\";\n\n/**\n * @template T\n * @param {import('@preact/signals-core').Signal<T>} signal \n * @returns {import('@preact/signals-core').ReadonlySignal<T>}\n */\nexport function readonly(signal) {\n  return computed(() => signal.value);\n}","import { effect, signal } from '@preact/signals-core';\n\n/**\n * @template T\n * @param {T | undefined} [initialValue]\n * @returns {import('./global.d.ts').Ref<T>}\n */\nexport function ref(initialValue) {\n  const refSignal = signal(initialValue);\n\n  /**\n   * @param {T | undefined} value \n   * @returns {void}\n   */\n  const refFn = (value) => {\n    refSignal.value = value;\n  };\n\n  Object.defineProperty(refFn, 'current', {\n    get() {\n      return refSignal.value;\n    },\n    enumerable: false,\n    configurable: false,\n  });\n\n  return refFn;\n};\n\n/**\n * @template T\n * @param {import('./global.d.ts').Ref<T>[]} refs\n */\nexport function forwardedRef(refs) {\n  /** @type {import('./global.d.ts').Ref<T>} */\n  const newRef = ref();\n\n  effect(() => {\n    refs.forEach((ref) => ref(newRef.current));\n  });\n\n  return newRef;\n}\n","import { computed, effect, signal } from '@preact/signals-core';\nimport { readonly } from '../readonly.js';\nimport { forwardedRef } from '../ref.js';\nimport { eventListener } from './eventListener.js';\nimport { mousedown } from './mousedown.js';\n\n/**\n * @param {object} [params]\n * @param {(event: DragEvent) => [string, string]} [params.getData] Returns a tuple of type and data\n */\nexport function draggable({ getData } = {}) {\n  const dragging = signal(false);\n\n  /** @type {ReturnType<typeof eventListener<'dragstart', HTMLElement>>} */\n  const { ref: dragstartRef, end: endDragstart } = eventListener(\n    'dragstart',\n    (event) => {\n      dragging.value = true;\n\n      if (getData) {\n        event.dataTransfer?.setData(...getData(event));\n      }\n    },\n  );\n\n  /** @type {ReturnType<typeof eventListener<'dragend', HTMLElement>>} */\n  const { ref: dragendRef, end: endDragend } = eventListener('dragend', () => {\n    dragging.value = false;\n  });\n\n  const {\n    ref: handleRef,\n    down: mouseIsDownOnHandle,\n    end: endMousedown,\n  } = mousedown();\n\n  const targetRef = forwardedRef([dragstartRef, dragendRef]);\n  const isDraggable = computed(\n    () => !handleRef.current || mouseIsDownOnHandle.value,\n  );\n\n  const end = effect(() => {\n    const target = targetRef.current;\n\n    if (target) {\n      target.draggable = isDraggable.value;\n    }\n  });\n\n  return {\n    ref: targetRef,\n    handleRef,\n    dragging: readonly(dragging),\n    end: () => {\n      end();\n      endDragstart();\n      endDragend();\n      endMousedown();\n    },\n  };\n}\n\n/**\n * @param {object} [params]\n * @param {(event: DragEvent) => void} [params.onDrop]\n */\nexport function droppable({ onDrop } = {}) {\n  const dropping = signal(false);\n\n  /** @type {ReturnType<typeof eventListener<'dragenter', HTMLElement>>} */\n  const { ref: dragenterRef, end: endDragenter } = eventListener(\n    'dragenter',\n    (event) => {\n      event.preventDefault();\n      dropping.value = true;\n    },\n  );\n\n  /** @type {ReturnType<typeof eventListener<'dragover', HTMLElement>>} */\n  const { ref: dragoverRef, end: endDragover } = eventListener(\n    'dragover',\n    (event) => event.preventDefault(),\n  );\n\n  /** @type {ReturnType<typeof eventListener<'dragleave', HTMLElement>>} */\n  const { ref: dragleaveRef, end: endDragleave } = eventListener(\n    'dragleave',\n    (event) => {\n      event.preventDefault();\n      const { clientX, clientY } = event;\n      const rect = dragleaveRef.current?.getBoundingClientRect();\n\n      if (\n        rect &&\n        (clientY <= rect.top ||\n          clientY >= rect.bottom ||\n          clientX <= rect.left ||\n          clientX >= rect.right)\n      ) {\n        dropping.value = false;\n      }\n    },\n  );\n\n  /** @type {ReturnType<typeof eventListener<'drop', HTMLElement>>} */\n  const { ref: dropRef, end: endDrop } = eventListener('drop', (event) => {\n    dropping.value = false;\n    onDrop?.(event);\n  });\n\n  const targetRef = forwardedRef([\n    dragenterRef,\n    dragoverRef,\n    dragleaveRef,\n    dropRef,\n  ]);\n\n  return {\n    ref: targetRef,\n    dropping: readonly(dropping),\n    end: () => {\n      endDragenter();\n      endDragover();\n      endDragleave();\n      endDrop();\n    },\n  };\n}\n","import { effect, signal } from \"@preact/signals-core\";\nimport { ref } from \"../ref.js\";\nimport { readonly } from \"../readonly.js\";\n\n/**\n * @template {import('../global.d.ts').EventName} T\n * @template {EventTarget} Target\n * @param {T} eventName\n * @param {(event: import('../global.d.ts').EventType<T>) => void} [callback]\n */\nexport function eventListener(eventName, callback) {\n  /** @type {import('../global.d.ts').Ref<Target>} */\n  const targetRef = ref();\n  /** @type {import('../global.d.ts').Signal<import('../global.d.ts').EventType<T> | null>} */\n  const eventSignal = signal(null);\n\n  const end = effect(() => {\n    const controller = new AbortController();\n    targetRef.current?.addEventListener(\n      eventName,\n      /** @param {import('../global.d.ts').EventType<T>} event */\n      // @ts-ignore\n      (event) => {\n        eventSignal.value = event;\n        callback?.(event);\n      },\n      { signal: controller.signal }\n    );\n\n    return () => controller.abort();\n  });\n  \n  return { targetRef, ref: targetRef, event: readonly(eventSignal), end };\n}\n","import { signal } from '@preact/signals-core';\nimport { eventListener } from './eventListener.js';\nimport { readonly } from '../readonly.js';\nimport { forwardedRef } from '../ref.js';\n\nexport function mousedown() {\n  const down = signal(false);\n\n  const { ref: mousedownRef, end: endMousedown } = eventListener(\n    'mousedown',\n    () => (down.value = true),\n  );\n\n  const { ref: mouseupRef, end: endMouseup } = eventListener(\n    'mouseup',\n    () => (down.value = false),\n  );\n\n  const end = () => {\n    endMousedown();\n    endMouseup();\n  };\n\n  return {\n    /** @type {import('../global.d.ts').Ref<Element>} */\n    // @ts-ignore\n    ref: forwardedRef([mousedownRef, mouseupRef]),\n    down: readonly(down),\n    end,\n    dispose: end,\n  };\n}\n","import { computed, signal } from '@preact/signals-core';\nimport { readonly } from '../readonly.js';\nimport { toggleValue } from '../tools/toggleValue.js';\n\nexport function showPassword(show = false) {\n  const { on: visible, toggle } = toggleValue(show);\n\n  return {\n    visible: readonly(visible),\n    inputType: computed(() => (visible.value ? 'text' : 'password')),\n    toggle,\n  };\n}\n","import { signal } from '@preact/signals-core';\nimport { readonly } from '../readonly.js';\n\nexport function toggleValue(initialOn = false) {\n  const on = signal(initialOn);\n\n  return {\n    on: readonly(on),\n    toggle() {\n      on.value = !on.value;\n    },\n  };\n}\n","import { computed, effect, signal } from '@preact/signals-core';\nimport { readonly } from '../readonly.js';\nimport { eventListener } from '../tools/eventListener.js';\n\n/**\n * @param {boolean} [initialIsToggled]\n */\nexport function toggleButton(initialIsToggled = false) {\n  const { ref: buttonRef } = eventListener(\n    'click',\n    () => (isToggled.value = !isToggled.value),\n  );\n  const isToggled = signal(initialIsToggled);\n  const ariaPressed = computed(() => (isToggled.value ? 'true' : 'false'));\n  const el = computed(() =>\n    buttonRef.current instanceof HTMLButtonElement ? buttonRef.current : null,\n  );\n  const dispose = effect(() =>\n    el.value?.setAttribute('aria-pressed', ariaPressed.value),\n  );\n\n  return {\n    /** @type {import('../global.d.ts').Ref<HTMLButtonElement>} */\n    // @ts-ignore\n    ref: buttonRef,\n    isToggled: readonly(isToggled),\n    dispose,\n  };\n}\n"],"names":[],"version":3,"file":"components.js.map","sourceRoot":"../../"}