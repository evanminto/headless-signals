{"mappings":"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","sources":["src/preact.js","src/preact/useHeadlessSignals.js","src/preact/useModalControl.js","src/components/modalControl.js","src/tools/eventListener.js","src/ref.js","src/readonly.js","src/preact/useReorderableList.js","src/components/reorderableList.js","src/tools/dragAndDrop.js","src/tools/mousedown.js"],"sourcesContent":["export * from './preact/useHeadlessSignals.js';\nexport * from './preact/useModalControl.js';\nexport * from './preact/useReorderableList.js';","import { useMemo, useRef } from 'preact/hooks';\n\nconst registry = new FinalizationRegistry(cleanupRef => {\n  cleanupRef.current && cleanupRef.current(); // cleanup on unmount\n});\n\n/**\n * A version of useMemo that allows cleanup. Return a tuple from the callback:\n * [returnValue, cleanupFunction]\n * @template T\n * @template {readonly any[]} Dependencies\n * @param {() => [T, () => void] | [T]} callback\n * @param {Dependencies} deps\n */\nfunction useMemoCleanup(callback, deps) {\n  /** @type {import('preact/hooks').MutableRef<(() => void) | null>} */\n  const cleanupRef = useRef(null); // holds a cleanup value\n  const unmountRef = useRef(false); // the GC-triggering candidate\n\n  if(!unmountRef.current) {\n      unmountRef.current = true;\n      // this works since refs are preserved for the component's lifetime\n      registry.register(unmountRef, cleanupRef);\n  }\n\n  const returned = useMemo(() => {\n      cleanupRef.current && cleanupRef.current();\n      cleanupRef.current = null;\n\n      const [returned, cleanup] = callback();\n      cleanupRef.current = typeof cleanup === \"function\" ? cleanup : null;\n\n      return returned;\n  }, deps);\n\n  return returned;\n}\n\n\n/**\n * @template {{ end?: () => void; dispose?: () => void }} Result\n * @template {(ReadonlyArray<any> | readonly [any])} Dependencies\n * @template {() => Result} CreateHeadlessSignalFn\n * @param {CreateHeadlessSignalFn} createHeadlessSignal \n * @param {Dependencies} [dependencies]\n * @returns {ReturnType<CreateHeadlessSignalFn>}\n */\nexport function useHeadlessSignals(\n  createHeadlessSignal,\n  // @ts-ignore\n  dependencies = []\n) {\n  const result = useMemoCleanup(() => {\n    const result = createHeadlessSignal();\n\n    if (result.end || result.dispose) {\n      const { end, dispose, ...rest } = result;\n      const cleanup = () => {\n        if (dispose) {\n          dispose();\n        } else if (end) {\n          end();\n        }\n      };\n\n      return [rest, cleanup];\n    }\n\n    return [result];\n  }, dependencies);\n\n  // @ts-ignore\n  return result;\n}","import { modalControl } from \"../components/modalControl.js\";\nimport { useHeadlessSignals } from \"./useHeadlessSignals.js\";\n\n/**\n * @param {Parameters<typeof modalControl>[0]} [options]\n */\nexport function useModalControl(options) {\n  return useHeadlessSignals(\n    () => modalControl(options),\n    [options?.action, options?.lightDismiss]\n  );\n}","import { computed, effect, signal } from '@preact/signals-core';\nimport { eventListener } from '../tools/eventListener.js';\nimport { readonly } from '../readonly.js';\n\nexport function modalControl({ lightDismiss = false, action = 'toggle' } = {}) {\n  const isOpen = signal(false);\n  const { ref: controlRef, end: disposeControl } = eventListener(\n    'click',\n    () => {\n      if (action === 'toggle') {\n        isOpen.value = !isOpen.value;\n      }\n    },\n  );\n\n  const { ref: modalRef, end: disposeModal } = eventListener('close', () => {\n    isOpen.value = false;\n  });\n\n  const modalEl = computed(() =>\n    modalRef.current instanceof HTMLDialogElement ? modalRef.current : null,\n  );\n\n  effect(() => {\n    if (modalEl.value) {\n      if (isOpen.value) {\n        modalEl.value.showModal();\n      } else {\n        modalEl.value.close();\n      }\n    }\n  });\n\n  return {\n    /** @type {import('../global.js').Ref<HTMLDialogElement>} */\n    // @ts-ignore\n    modalRef,\n    /** @type {import('../global.js').Ref<HTMLButtonElement>} */\n    // @ts-ignore\n    controlRef,\n    isOpen: readonly(isOpen),\n    dispose: () => {\n      disposeControl();\n      disposeModal();\n    },\n  };\n}\n","import { effect, signal } from \"@preact/signals-core\";\nimport { ref } from \"../ref.js\";\nimport { readonly } from \"../readonly.js\";\n\n/**\n * @template {import('../global.d.ts').EventName} T\n * @template {EventTarget} Target\n * @param {T} eventName\n * @param {(event: import('../global.d.ts').EventType<T>) => void} [callback]\n */\nexport function eventListener(eventName, callback) {\n  /** @type {import('../global.d.ts').Ref<Target>} */\n  const targetRef = ref();\n  /** @type {import('../global.d.ts').Signal<import('../global.d.ts').EventType<T> | null>} */\n  const eventSignal = signal(null);\n\n  const end = effect(() => {\n    const controller = new AbortController();\n    targetRef.current?.addEventListener(\n      eventName,\n      /** @param {import('../global.d.ts').EventType<T>} event */\n      // @ts-ignore\n      (event) => {\n        eventSignal.value = event;\n        callback?.(event);\n      },\n      { signal: controller.signal }\n    );\n\n    return () => controller.abort();\n  });\n  \n  return { targetRef, ref: targetRef, event: readonly(eventSignal), end };\n}\n","import { effect, signal } from '@preact/signals-core';\n\n/**\n * @template T\n * @param {T | undefined} [initialValue]\n * @returns {import('./global.d.ts').Ref<T>}\n */\nexport function ref(initialValue) {\n  const refSignal = signal(initialValue);\n\n  /**\n   * @param {T | undefined} value \n   * @returns {void}\n   */\n  const refFn = (value) => {\n    refSignal.value = value;\n  };\n\n  Object.defineProperty(refFn, 'current', {\n    get() {\n      return refSignal.value;\n    },\n    enumerable: false,\n    configurable: false,\n  });\n\n  return refFn;\n};\n\n/**\n * @template T\n * @param {import('./global.d.ts').Ref<T>[]} refs\n */\nexport function forwardedRef(refs) {\n  /** @type {import('./global.d.ts').Ref<T>} */\n  const newRef = ref();\n\n  effect(() => {\n    refs.forEach((ref) => ref(newRef.current));\n  });\n\n  return newRef;\n}\n","import { computed } from \"@preact/signals-core\";\n\n/**\n * @template T\n * @param {import('@preact/signals-core').Signal<T>} signal \n * @returns {import('@preact/signals-core').ReadonlySignal<T>}\n */\nexport function readonly(signal) {\n  return computed(() => signal.value);\n}","import { reorderableList } from \"../components/reorderableList.js\";\nimport { useHeadlessSignals } from \"./useHeadlessSignals.js\";\n\n/**\n * @template T\n * @param {Parameters<typeof reorderableList<T>>[0]} [list]\n */\nexport function useReorderableList(list = []) {\n  return useHeadlessSignals(() => reorderableList(list), [list]);\n}","import { effect, signal } from '@preact/signals-core';\nimport { readonly } from '../readonly.js';\nimport { forwardedRef } from '../ref.js';\nimport { draggable, droppable } from '../tools/dragAndDrop.js';\n\n/**\n * @template T\n * @param {T[]} items\n */\nexport function reorderableList(items = []) {\n  const itemsSignal = signal(items);\n  /**\n   * @type {import('../global.d.ts').Signal<{\n   *   item: T;\n   *   dragging: import('../global.d.ts').ReadonlySignal<boolean>;\n   *   dropping: import('../global.d.ts').ReadonlySignal<boolean>;\n   *   ref: import('../global.d.ts').Ref<HTMLElement>;\n   *   handleRef: import('../global.d.ts').Ref<Element>;\n   *   draggableRef: import('../global.d.ts').Ref<HTMLElement>;\n   *   droppableRef: import('../global.d.ts').Ref<HTMLElement>;\n   *   moveUp: () => void;\n   *   moveDown: () => void;\n   *   moveToTop: () => void;\n   * }[]>}\n   */\n  const wrappedItemsSignal = signal([]);\n\n  /**\n   * @param {number} from \n   * @param {number} to \n   */\n  function moveToIndex(from, to) {\n    const arr = [...itemsSignal.value];\n\n    if (to < 0 || to > arr.length - 1) {\n      return;\n    }\n\n    const element = arr.splice(from, 1)[0];\n    arr.splice(to, 0, element);\n    itemsSignal.value = arr;\n  }\n\n  const end = effect(() => {\n    const wrappedItems = itemsSignal.value.map((item, index) => {\n      const {\n        ref: draggableRef,\n        handleRef,\n        dragging,\n        end: endDraggable,\n      } = draggable({ getData: () => ['text', index.toString()] });\n\n      const {\n        ref: droppableRef,\n        dropping,\n        end: endDroppable,\n      } = droppable({\n        onDrop: (event) => {\n          const data = event.dataTransfer?.getData('text');\n\n          if (data) {\n            moveToIndex(parseInt(data, 10), index);\n          }\n        },\n      });\n\n      return {\n        item,\n        dragging,\n        dropping,\n        ref: forwardedRef([draggableRef, droppableRef]),\n        handleRef,\n        draggableRef,\n        droppableRef,\n        moveUp: () => moveToIndex(index, index - 1),\n        moveDown: () => moveToIndex(index, index + 1),\n        moveToTop: () => moveToIndex(index, 0),\n        end: () => {\n          endDraggable();\n          endDroppable();\n        },\n      };\n    }).flat();\n\n    wrappedItemsSignal.value = wrappedItems.map(({ end, ...item }) => item);\n\n    return () => wrappedItems.forEach(({ end }) => end());\n  });\n\n  return {\n    items: readonly(wrappedItemsSignal),\n    end,\n  }\n}\n","import { computed, effect, signal } from '@preact/signals-core';\nimport { readonly } from '../readonly.js';\nimport { forwardedRef } from '../ref.js';\nimport { eventListener } from './eventListener.js';\nimport { mousedown } from './mousedown.js';\n\n/**\n * @param {object} [params]\n * @param {(event: DragEvent) => [string, string]} [params.getData] Returns a tuple of type and data\n */\nexport function draggable({ getData } = {}) {\n  const dragging = signal(false);\n\n  /** @type {ReturnType<typeof eventListener<'dragstart', HTMLElement>>} */\n  const { ref: dragstartRef, end: endDragstart } = eventListener(\n    'dragstart',\n    (event) => {\n      dragging.value = true;\n\n      if (getData) {\n        event.dataTransfer?.setData(...getData(event));\n      }\n    },\n  );\n\n  /** @type {ReturnType<typeof eventListener<'dragend', HTMLElement>>} */\n  const { ref: dragendRef, end: endDragend } = eventListener('dragend', () => {\n    dragging.value = false;\n  });\n\n  const {\n    ref: handleRef,\n    down: mouseIsDownOnHandle,\n    end: endMousedown,\n  } = mousedown();\n\n  const targetRef = forwardedRef([dragstartRef, dragendRef]);\n  const isDraggable = computed(\n    () => !handleRef.current || mouseIsDownOnHandle.value,\n  );\n\n  const end = effect(() => {\n    const target = targetRef.current;\n\n    if (target) {\n      target.draggable = isDraggable.value;\n    }\n  });\n\n  return {\n    ref: targetRef,\n    handleRef,\n    dragging: readonly(dragging),\n    end: () => {\n      end();\n      endDragstart();\n      endDragend();\n      endMousedown();\n    },\n  };\n}\n\n/**\n * @param {object} [params]\n * @param {(event: DragEvent) => void} [params.onDrop]\n */\nexport function droppable({ onDrop } = {}) {\n  const dropping = signal(false);\n\n  /** @type {ReturnType<typeof eventListener<'dragenter', HTMLElement>>} */\n  const { ref: dragenterRef, end: endDragenter } = eventListener(\n    'dragenter',\n    (event) => {\n      event.preventDefault();\n      dropping.value = true;\n    },\n  );\n\n  /** @type {ReturnType<typeof eventListener<'dragover', HTMLElement>>} */\n  const { ref: dragoverRef, end: endDragover } = eventListener(\n    'dragover',\n    (event) => event.preventDefault(),\n  );\n\n  /** @type {ReturnType<typeof eventListener<'dragleave', HTMLElement>>} */\n  const { ref: dragleaveRef, end: endDragleave } = eventListener(\n    'dragleave',\n    (event) => {\n      event.preventDefault();\n      const { clientX, clientY } = event;\n      const rect = dragleaveRef.current?.getBoundingClientRect();\n\n      if (\n        rect &&\n        (clientY <= rect.top ||\n          clientY >= rect.bottom ||\n          clientX <= rect.left ||\n          clientX >= rect.right)\n      ) {\n        dropping.value = false;\n      }\n    },\n  );\n\n  /** @type {ReturnType<typeof eventListener<'drop', HTMLElement>>} */\n  const { ref: dropRef, end: endDrop } = eventListener('drop', (event) => {\n    dropping.value = false;\n    onDrop?.(event);\n  });\n\n  const targetRef = forwardedRef([\n    dragenterRef,\n    dragoverRef,\n    dragleaveRef,\n    dropRef,\n  ]);\n\n  return {\n    ref: targetRef,\n    dropping: readonly(dropping),\n    end: () => {\n      endDragenter();\n      endDragover();\n      endDragleave();\n      endDrop();\n    },\n  };\n}\n","import { signal } from '@preact/signals-core';\nimport { eventListener } from './eventListener.js';\nimport { readonly } from '../readonly.js';\nimport { forwardedRef } from '../ref.js';\n\nexport function mousedown() {\n  const down = signal(false);\n\n  const { ref: mousedownRef, end: endMousedown } = eventListener(\n    'mousedown',\n    () => (down.value = true),\n  );\n\n  const { ref: mouseupRef, end: endMouseup } = eventListener(\n    'mouseup',\n    () => (down.value = false),\n  );\n\n  const end = () => {\n    endMousedown();\n    endMouseup();\n  };\n\n  return {\n    /** @type {import('../global.d.ts').Ref<Element>} */\n    // @ts-ignore\n    ref: forwardedRef([mousedownRef, mouseupRef]),\n    down: readonly(down),\n    end,\n    dispose: end,\n  };\n}\n"],"names":[],"version":3,"file":"preact.js.map","sourceRoot":"../../"}